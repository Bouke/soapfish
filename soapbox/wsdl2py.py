from optparse import OptionParser
from lxml import etree
from jinja2 import Environment
from wsdl import get_wsdl_classes, get_by_name
from utils import removens, classyfiy, get_get_type, use, find_xsd_namepsace, urlcontext
from xsd2py import schema_to_py, schema_name, open_document
from soap import SOAP_HTTP_Transport, SOAPVersion


environment = Environment(extensions=['jinja2.ext.loopcontrols'])
environment.filters["class"] = classyfiy
environment.filters["removens"] = removens
environment.filters["use"] = use
environment.filters["urlcontext"] = urlcontext
environment.globals["get_by_name"] = get_by_name
environment.globals["SOAPTransport"] = SOAP_HTTP_Transport
environment.globals["schema_name"] = schema_name

TEMPLATE = """#This was was generated by wsdl2py, try to not edit.
from soapbox import soap
from soapbox import xsd
from soapbox.xsd import UNBOUNDED
{%- if schema %}
{{schema}}
{%- endif %}

{%- for service in definitions.services %}
{% for port in service.ports %}

{%- set binding = get_by_name(definitions.bindings,port.binding) %}
{%- set XXX = binding.set_definition(definitions) %}
{%- set XXX = binding.feedback_Operations() %}

{%- if binding.binding.transport != SOAPTransport %}
    {% continue %}
{% endif %}

    {%- for operation in binding.operations %}
        {%- set XXX = operation.set_definition(definitions) %}
        {%- set inputMessage = operation.get_InputMessage() %}
        {%- set outputMessage = operation.get_OutputMessage() %}

{% if is_server %}
def {{operation.name}}(request,{{inputMessage.part.element|removens}}):
    #Put your implementation here.
    return {{outputMessage.part.element|removens}}
{%- endif %}

{{operation.name}}_method = xsd.Method(
    {%- if is_server %}function = {{operation.name}},{% endif %}
    soapAction = "{{operation.operation.soapAction}}",
    {%- if inputMessage.part.element %}
    input = "{{inputMessage.part.element|removens}}",#Pointer to Schema.elements
    inputPartName = "{{inputMessage.part.name}}",
    {%- else %}
    input = {{inputMessage.part.type|removens|class}},
    {%- endif %}
    {%- if inputMessage.part.element %}
    output = "{{outputMessage.part.element|removens}}",#Pointer to Schema.elements
    outputPartName = "{{outputMessage.part.name}}",
    {%- else %}
    input = {{outputMessage.part.type|removens|class}},
    {%- endif %}
    operationName = "{{operation.name}}",
    {%- if operation.operation.style %}
    style = "{{operation.operation.style}}",
    {%- endif %})

    {% endfor %}

{{port.name}}_SERVICE = soap.Service(
    name = "{{port.name}}",
    targetNamespace = "{{definitions.targetNamespace}}",
    location = "{{port.address.location}}",
    schema = Schema{{schema_name(definitions.types.schema.targetNamespace)}},
    version = soap.SOAPVersion.SOAP11,
    methods = [{% for o in binding.operations %}{{o.name}}_method,{% endfor %} ])

{% if is_server %}
#Uncomment this lines to turn on dispatching.
#from django.views.decorators.csrf import csrf_exempt
#dispatch = csrf_exempt(soap.get_django_dispatch({{port.name}}_SERVICE))

#Put this lines in your urls.py:
#urlpatterns += patterns('',
#    (r"{{service.ports.0.address.location|urlcontext}}", "<fill the module path>.dispatch")
#)
{%- else %}
class {{port.name}}ServiceStub(soap.Stub):
    SERVICE = {{port.name}}_SERVICE

    {% for operation in binding.operations %}
        {%- set inputMessage = operation.get_InputMessage() %}
        {%- set outputMessage = operation.get_OutputMessage() %}
    def {{operation.name}}(self, {{inputMessage.part.element|removens}}):
        return self.call("{{operation.name}}", {{inputMessage.part.element|removens}})
    {% endfor %}
{%- endif %}

{% endfor %} {# ports for #}
{% endfor %} {# services for #}
"""


def generate_code_from_wsdl(is_server, xml):
    xmlelement = etree.fromstring(xml)
    XSD_NAMESPACE = find_xsd_namepsace(xmlelement.nsmap)
    environment.filters["type"] = get_get_type(XSD_NAMESPACE)

    wsdl = get_wsdl_classes(SOAPVersion.SOAP11.BINDING_NAMESPACE)
    definitions = wsdl.Definitions.parse_xmlelement(xmlelement)
    schema = definitions.types.schema
    xsd_namespace = find_xsd_namepsace(xmlelement.nsmap)
    schemaxml = schema_to_py(schema, xsd_namespace)
    return environment.from_string(TEMPLATE).render(
            definitions=definitions,
            schema=schemaxml,
            is_server=is_server)


def console_main():
    parser = OptionParser(usage="usage: %prog [-c|-s] path_to_wsdl")
    parser.add_option("-c", "--client", dest="client",
                  help="Generate webservice http client code.")
    parser.add_option("-s", "--server", dest="server",
                  help="Generate webservice Django server code.")
    (options, args) = parser.parse_args()
    if options.client and options.server:
        parser.error("Options -c and -s are mutually exclusive")
    elif options.client:
        xml = open_document(options.client)
        print generate_code_from_wsdl(False, xml)
    elif options.server:
        xml = open_document(options.server)
        print generate_code_from_wsdl(True, xml)
    else:
        parser.print_help()


if __name__ == "__main__":
    console_main()
    #url = "http://ec2-46-137-40-70.eu-west-1.compute.amazonaws.com/QPulse5WebServices/Services/Core.svc?wsdl"
    #resolve_imports(url)
